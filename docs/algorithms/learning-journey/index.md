---
title: DSA Learning Journey
---
Before the dawn of the information era, knowledge was scarce, and always came at a premium price. These days, knowledge is essentially free - the internet is brimming with it, and LLMs can retrieve it for us at lightning-fast speeds. However, nowadays we face a different problem - there is so much knowledge available that we often get lost in it. Our time is a limited resource, and we simply don't have enough of it to learn all the things we would like to know.

My goal in creating this learning path was simple - cram all the essential knowledge that forms the foundations of computer science and DSA into one structured, focused curriculum. Instead of saturating you with information, this path helps you reason your way through the world of software engineering. The pace is slow, the scope is deep, and the goal is to help you truly understand things - not only the how, but also the why behind them.

This journey is a mirror of my own personal curiosity and where it led me - it gradually builds one concept over another to help you understand the big picture.

## What's Wrong with DSA?

**Algorithms & Data Structures** are perhaps the most universally hated aspect of software engineering. They are usually taught in a rigid, tedious, and rather uninteresting manner, in total isolation from practical reality. However, in my humble opinion, the topic itself isn't inherently boring or impractical. It's just that we approach it the wrong way.

Most companies these days still use DSA as an easy way to filter out unprepared candidates. This is inherently wrong - but it is the harsh reality. As consequence, aspiring developers begin a slow *leetcode* grind, hoping that solving hundreds of problems can somehow give them an edge in technical interviews and help them land their dream job. This creates a vicious cycle - developers learn DSA not because they want to, but because it is required of them - and since learning something you don't want to learn is in general considered a chore, we begin to nurture a hatred towards the accursed topic.

However, there is a better way. Learning is much more pleasant when you approach it methodically and diligently, using your innate curiosity to fuel it rather than being compelled by the shape of current social norms. And as it turns out, DSA doesn't have to be as hard as it seems - at their core, all algorithm problems are based on certain patterns. If we can truly understand those patterns, we can solve any problem by simply recognizing which pattern it follows.

This is the modern approach to learn DSA - and it is the route we will take on this path.

## The Path Ahead

This learning journey is structured as a progression, where each section builds on the last. It is designed to be completed sequentially, but you may also skip around if you wish.

### Fundamentals

Modern technology has advanced so far that we are able to write complex software without needing to know what a computer really is or how it works. However, there is a certain power in understanding how the software you write traverses all the layers of abstraction and is ultimately executed by the CPU as a set of simple instructions. Of course, you could spend years studying the internal workings of a computer - but for our needs, a deep dive into established computer science fundamentals will suffice.

From binary, transistors and logic gates, through assembly, programming languages and OOP / functional programming paradigms, to algorithms and the Big O notation, this section covers everything you need to truly understand computers.

### Data Structures

Before starting to build problem solving skills, it is essential to have a solid grasp of data structures. Those are the tools that we have at our disposal - each works best for different types of problems. Learning to implement them, manipulate them, and use them in practice provides us with a solid foundation we can then build upon.

This section examines the strengths & weaknesses of each data structure, discusses its low-level implementation, and provides easy practice problems to build a sort of "muscle memory" for handling them.

### Sorting Algorithms

Sorting is the perfect starting point for studying algorithms. It teaches us algorithmic thinking and the Big O notation with a set of practical but moderately easy problems. This section is therefore sort of an appetizer - reinforcing what we've learned so far before we move to more complex material.

### Algorithm Patterns

Finally, we arrive at the heart of problem-solving: recognizing and applying patterns. Binary search, two pointers, depth-first search, dynamic programming... these are not just algorithms, but ways of thinking. Each pattern is a lens through which entire categories of problems become approachable. We will go through each pattern in great detail, providing plenty of practice problems to test your knowledge.
